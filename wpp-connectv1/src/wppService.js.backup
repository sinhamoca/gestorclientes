/* ==========================================
   WPPCONNECT SERVICE - L√≥gica Principal
   ========================================== */

import wppconnect from '@wppconnect-team/wppconnect';
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';
import logger from './utils/logger.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class WPPService {
  constructor() {
    this.sessions = new Map();
    // üî• CORRETO: /app/sessions (mapeado para volume Docker)
    this.sessionsPath = path.join(__dirname, '..', 'sessions');
    this.qrCodeCallbacks = new Map();
    this.statusCallbacks = new Map();
    this.chromePids = new Map(); // Rastrear PIDs do Chrome
    
    // Criar pasta de sess√µes
    if (!fs.existsSync(this.sessionsPath)) {
      fs.mkdirSync(this.sessionsPath, { recursive: true });
      logger.info('üìÅ Pasta de sess√µes criada');
    }

    // Cleanup inicial de processos Chrome √≥rf√£os
    this._cleanupOrphanedChrome();

    // üÜï CARREGAR SESS√ïES EXISTENTES NO STARTUP
    this._loadExistingSessions();

    logger.info('‚úÖ WPPService inicializado');
  }

  /**
   * üÜï Carregar sess√µes existentes no startup
   * Reconecta automaticamente sess√µes que t√™m tokens salvos
   */
  async _loadExistingSessions() {
    try {
      logger.info('üîÑ Verificando sess√µes existentes...');
      
      // Ler pastas na sessionsPath
      const sessionFolders = fs.readdirSync(this.sessionsPath, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name);

      if (sessionFolders.length === 0) {
        logger.info('   ‚ÑπÔ∏è  Nenhuma sess√£o anterior encontrada');
        return;
      }

      logger.info(`   üìÇ Encontradas ${sessionFolders.length} sess√£o(√µes) para restaurar`);

      // üî• IMPORTANTE: Limpar locks ANTES de tentar restaurar
      for (const sessionId of sessionFolders) {
        await this._removeLockFiles(sessionId);
      }

      // Reconectar cada sess√£o em paralelo (mas com limite)
      for (const sessionId of sessionFolders) {
        // N√£o bloquear o startup - fazer em background
        this._restoreSession(sessionId).catch(error => {
          logger.warn(`   ‚ö†Ô∏è  Erro ao restaurar ${sessionId}:`, error.message);
        });
        
        // Pequeno delay entre cada tentativa para n√£o sobrecarregar
        await new Promise(resolve => setTimeout(resolve, 2000));
      }

    } catch (error) {
      logger.error('‚ùå Erro ao carregar sess√µes existentes:', error);
    }
  }

  /**
   * üÜï Remover arquivos de lock do Chrome
   */
  async _removeLockFiles(sessionId) {
    try {
      const sessionPath = path.join(this.sessionsPath, sessionId);
      
      // Arquivos de lock que o Chrome cria
      const lockFiles = [
        'SingletonLock',
        'SingletonSocket',
        'SingletonCookie'
      ];

      for (const lockFile of lockFiles) {
        const lockPath = path.join(sessionPath, lockFile);
        if (fs.existsSync(lockPath)) {
          try {
            fs.unlinkSync(lockPath);
            logger.info(`   üîì Lock removido: ${sessionId}/${lockFile}`);
          } catch (err) {
            logger.warn(`   ‚ö†Ô∏è  N√£o foi poss√≠vel remover lock ${lockFile}:`, err.message);
          }
        }
      }
    } catch (error) {
      logger.warn(`   ‚ö†Ô∏è  Erro ao remover locks de ${sessionId}:`, error.message);
    }
  }

  /**
   * üÜï Restaurar uma sess√£o espec√≠fica
   */
  async _restoreSession(sessionId) {
    try {
      logger.info(`   üîå Restaurando sess√£o: ${sessionId}`);

      // üî• FOR√áAR diret√≥rio de dados do Chrome
      const userDataDir = path.join(this.sessionsPath, sessionId);

      // Criar cliente WPP Connect sem gerar novo QR
      const client = await wppconnect.create({
        session: sessionId,
        folderNameToken: this.sessionsPath,
        puppeteerOptions: {
          userDataDir: userDataDir,
          args: [
            `--user-data-dir=${userDataDir}`,  // üî• FOR√áAR via argumento
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-accelerated-2d-canvas',
            '--no-first-run',
            '--no-zygote',
            '--disable-gpu',
            '--disable-extensions'
          ],
          headless: process.env.HEADLESS !== 'false'
        },
        logQR: false, // N√£o mostrar QR no log
        disableWelcome: true,
        updatesLog: false,
        autoClose: 86400000, // 24h
        
        // Callbacks para monitorar status
        statusFind: (statusSession) => {
          if (statusSession === 'isLogged') {
            logger.info(`   ‚úÖ Sess√£o ${sessionId} autenticada`);
          } else if (statusSession === 'notLogged') {
            logger.warn(`   ‚ö†Ô∏è  Sess√£o ${sessionId} precisa reautenticar (tokens expirados)`);
          }
        }
      });

      // üÜï AGUARDAR SINCRONIZA√á√ÉO (at√© 30 segundos)
      let attempts = 0;
      let isReady = false;
      
      while (attempts < 30 && !isReady) {
        try {
          const state = await client.getConnectionState();
          
          // Aceitar CONNECTED ou SYNCING como v√°lidos
          if (state === 'CONNECTED' || state === 'SYNCING') {
            isReady = true;
            logger.info(`   ‚úÖ Sess√£o ${sessionId} em estado: ${state}`);
            break;
          }
          
          // Se n√£o conectado, aguardar 1 segundo e tentar novamente
          await new Promise(resolve => setTimeout(resolve, 1000));
          attempts++;
          
        } catch (error) {
          // Ignorar erros durante tentativas
          await new Promise(resolve => setTimeout(resolve, 1000));
          attempts++;
        }
      }

      if (isReady) {
        // Adicionar ao mapa de sess√µes MESMO se estiver SYNCING
        this.sessions.set(sessionId, client);
        logger.info(`   ‚úÖ ${sessionId} restaurada e adicionada ao mapa`);
        
        // Obter informa√ß√µes da sess√£o (pode falhar se ainda sincronizando)
        try {
          const hostDevice = await client.getHostDevice();
          if (hostDevice?.id?.user) {
            logger.info(`   üì± N√∫mero conectado: ${hostDevice.id.user}`);
          }
        } catch (err) {
          logger.info(`   ‚è≥ Sess√£o ${sessionId} ainda sincronizando dados...`);
        }
        
        return true;
      } else {
        logger.warn(`   ‚ö†Ô∏è  ${sessionId} n√£o conectou ap√≥s 30 segundos`);
        await client.close();
        return false;
      }

    } catch (error) {
      logger.warn(`   ‚ö†Ô∏è  N√£o foi poss√≠vel restaurar ${sessionId}: ${error.message}`);
      return false;
    }
  }

  /**
   * Limpar processos Chrome √≥rf√£os (travados)
   */
  async _cleanupOrphanedChrome() {
    try {
      const { execSync } = await import('child_process');
      
      // Matar processos Chrome √≥rf√£os (que n√£o est√£o sendo usados)
      execSync('pkill -f "chrome.*--user-data-dir=/app/sessions" || true', { 
        stdio: 'ignore' 
      });
      
      logger.info('üßπ Cleanup de processos Chrome √≥rf√£os conclu√≠do');
    } catch (error) {
      logger.warn('Aviso: N√£o foi poss√≠vel fazer cleanup de Chrome √≥rf√£os:', error.message);
    }
  }

  /**
   * Criar ou conectar sess√£o
   */
  async createSession(sessionId) {
    logger.info(`üì± Criando sess√£o: ${sessionId}`);

    try {
      // VERIFICAR SE H√Å CHROME TRAVADO PARA ESTA SESS√ÉO
      await this._checkAndKillStuckChrome(sessionId);
      
      // Limpar sess√£o anterior se existir (cleanup de Chrome travado)
      await this._forceCloseSession(sessionId);

      // Se j√° existe sess√£o ativa, verifica
      if (this.sessions.has(sessionId)) {
        const session = this.sessions.get(sessionId);
        const isConnected = await this._isSessionConnected(session);
        
        if (isConnected) {
          logger.info(`‚úÖ Sess√£o ${sessionId} j√° conectada`);
          return { success: true, message: 'J√° conectado', needsQR: false };
        }
        
        // Desconectada, remove e reconecta
        logger.warn(`‚ö†Ô∏è  Sess√£o ${sessionId} desconectada, reconectando...`);
        await this._closeSession(sessionId);
      }

      // üî• FOR√áAR diret√≥rio de dados do Chrome
      const userDataDir = path.join(this.sessionsPath, sessionId);

      // Promessa para aguardar QR ou conex√£o
      const sessionPromise = new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('Timeout aguardando QR Code'));
        }, (process.env.QR_TIMEOUT || 45) * 1000);

        wppconnect.create({
          session: sessionId,
          // For√ßa pasta √∫nica por sess√£o
          folderNameToken: this.sessionsPath,
          
          // üî• CR√çTICO: Define userDataDir √∫nico por sess√£o para evitar conflitos
          puppeteerOptions: {
            userDataDir: userDataDir,
            
            // Headless otimizado (mais leve que GUI)
            headless: process.env.HEADLESS !== 'false',  // Default: true
            
            // Argumentos otimizados para menor consumo
            args: [
              // üî• FOR√áAR diret√≥rio de dados via argumento
              `--user-data-dir=${userDataDir}`,
              
              // ========== SEGURAN√áA ==========
              '--no-sandbox',
              '--disable-setuid-sandbox',
              
              // ========== MEM√ìRIA ==========
              '--disable-dev-shm-usage',           // N√£o usar /dev/shm (pode dar problema em Docker)
              '--disable-accelerated-2d-canvas',   // Desabilitar canvas acelerado
              '--no-first-run',                    // Pular primeiro run
              '--no-zygote',                       // Reduzir processos filho
              '--disable-gpu',                     // Sem GPU (headless)
              
              // ========== REDE ==========
              '--disable-background-networking',   // Sem sync em background
              '--disable-sync',                    // Sem sincroniza√ß√£o Chrome
              '--disable-translate',               // Sem tradutor
              '--disable-default-apps',            // Sem apps padr√£o
              
              // ========== PERFORMANCE ==========
              '--disable-extensions',              // Sem extens√µes
              '--disable-plugins',                 // Sem plugins
              '--disable-component-extensions-with-background-pages',
              '--disable-background-timer-throttling',
              '--disable-renderer-backgrounding',
              '--disable-backgrounding-occluded-windows',
              '--disable-ipc-flooding-protection',
              '--disable-hang-monitor',
              '--disable-prompt-on-repost',
              '--disable-domain-reliability',
              '--disable-features=TranslateUI',
              '--disable-features=BlinkGenPropertyTrees',
              
              // ========== CACHE E ARMAZENAMENTO ==========
              '--disk-cache-size=50000000',        // Cache de 50MB (pequeno)
              '--media-cache-size=50000000',
              '--aggressive-cache-discard',
              '--disable-notifications',
              '--disable-speech-api',
              
              // ========== √ÅUDIO/V√çDEO ==========
              '--mute-audio',                      // Sem √°udio
              '--disable-webgl',                   // Sem WebGL
              '--disable-software-rasterizer',
              
              // ========== OUTROS ==========
              '--no-pings',
              '--no-default-browser-check',
              '--autoplay-policy=user-gesture-required',
              '--disable-client-side-phishing-detection',
              '--disable-features=IsolateOrigins,site-per-process',
              
              // ========== LIMITES DE RECURSOS ==========
              '--single-process',                  // üî• IMPORTANTE: Um √∫nico processo
              '--disable-renderer-backgrounding',
              '--renderer-process-limit=1',        // Apenas 1 processo renderer
              '--max-old-space-size=512',          // Limite de mem√≥ria Node.js: 512MB
            ],
            
            // ========== TIMEOUTS AJUSTADOS ==========
            timeout: 60000,  // 60s para opera√ß√µes (padr√£o √© 30s)
            
            // ========== IGNORAR ERROS DE HTTPS ==========
            ignoreHTTPSErrors: true,
          },
        
          // ========== üÜï CONFIGURA√á√ïES WPPCONNECT ==========
          disableWelcome: true,              // Sem mensagem de boas-vindas
          updatesLog: false,   
          headless: process.env.HEADLESS === 'true',
          devtools: false,
          useChrome: false,
          debug: false,
          logQR: false,
          autoClose: 60000 * 60 * 24,
          createPathFileToken: true,
          waitForLogin: true,
          
          // QR Code gerado
          catchQR: (base64Qr, asciiQR, attempts, urlCode) => {
            clearTimeout(timeout);
            logger.info(`üì≤ QR Code gerado para ${sessionId} (tentativa ${attempts})`);
            
            // Chamar callback se registrado
            const callback = this.qrCodeCallbacks.get(sessionId);
            if (callback) {
              callback({ qrCode: base64Qr, attempts, urlCode });
            }
            
            resolve({ 
              success: true, 
              needsQR: true, 
              qrCode: base64Qr,
              attempts 
            });
          },

          // Status mudou
          statusFind: (statusSession, session) => {
            logger.info(`üìä Status ${sessionId}: ${statusSession}`);
            
            const callback = this.statusCallbacks.get(sessionId);
            if (callback) {
              callback({ status: statusSession });
            }

            // Se conectado com sucesso
            if (statusSession === 'qrReadSuccess') {
              logger.info(`‚úÖ ${sessionId} conectado com sucesso!`);
            }
          }
        })
        .then(client => {
          this.sessions.set(sessionId, client);
          logger.info(`‚úÖ Cliente ${sessionId} criado e salvo`);
        })
        .catch(error => {
          clearTimeout(timeout);
          logger.error(`‚ùå Erro ao criar ${sessionId}:`, error);
          reject(error);
        });
      });

      return await sessionPromise;

    } catch (error) {
      logger.error(`‚ùå Erro em createSession (${sessionId}):`, error);
      throw error;
    }
  }

  /**
   * Obter informa√ß√µes da sess√£o
   */
  async getSessionInfo(sessionId) {
    const session = this.sessions.get(sessionId);
    
    if (!session) {
      return { connected: false, message: 'Sess√£o n√£o encontrada' };
    }

    try {
      const isConnected = await this._isSessionConnected(session);
      
      if (!isConnected) {
        return { connected: false, message: 'Desconectado' };
      }

      const hostDevice = await session.getHostDevice();
      const state = await session.getConnectionState();
      
      return {
        connected: true,
        phoneNumber: hostDevice?.id?.user || null,
        platform: hostDevice?.platform || null,
        pushname: hostDevice?.pushname || null,
        state: state
      };

    } catch (error) {
      logger.error(`‚ùå Erro ao obter info (${sessionId}):`, error);
      return { connected: false, error: error.message };
    }
  }

  /**
   * Enviar mensagem de texto
   */
  async sendMessage(sessionId, phoneNumber, message) {
    const session = this.sessions.get(sessionId);
    
    if (!session) {
      throw new Error(`Sess√£o ${sessionId} n√£o encontrada`);
    }

    const isConnected = await this._isSessionConnected(session);
    if (!isConnected) {
      throw new Error(`Sess√£o ${sessionId} n√£o est√° conectada`);
    }

    try {
      // Formatar n√∫mero
      const formattedNumber = phoneNumber.replace(/\D/g, '');
      const chatId = formattedNumber.includes('@') 
        ? formattedNumber 
        : `${formattedNumber}@c.us`;

      logger.info(`üì§ Enviando mensagem via ${sessionId} para ${chatId}`);

      const result = await session.sendText(chatId, message);
      
      logger.info(`‚úÖ Mensagem enviada com sucesso`);
      
      return { 
        success: true, 
        messageId: result.id,
        timestamp: result.t
      };

    } catch (error) {
      logger.error(`‚ùå Erro ao enviar mensagem:`, error);
      throw error;
    }
  }

  /**
   * Verificar se n√∫mero existe no WhatsApp
   */
  async checkNumberStatus(sessionId, phoneNumber) {
    const session = this.sessions.get(sessionId);
    
    if (!session) {
      throw new Error(`Sess√£o ${sessionId} n√£o encontrada`);
    }

    const isConnected = await this._isSessionConnected(session);
    if (!isConnected) {
      throw new Error(`Sess√£o ${sessionId} n√£o est√° conectada`);
    }

    try {
      // Formatar n√∫mero
      const formattedNumber = phoneNumber.replace(/\D/g, '');
      const chatId = `${formattedNumber}@c.us`;
      
      logger.info(`üîç Verificando n√∫mero: ${formattedNumber}`);
      
      // Usar checkNumberStatus do WPPConnect
      const result = await session.checkNumberStatus(chatId);
      
      logger.info(`   üìã Resultado: ${JSON.stringify(result)}`);
      
      // WPPConnect retorna: { id, status, isBusiness, canReceiveMessage }
      const exists = result.status === 200 || result.numberExists === true || result.canReceiveMessage === true;
      
      return {
        success: true,
        exists: exists,
        number: formattedNumber,
        numberFormatted: chatId,
        isBusiness: result.isBusiness || false,
        canReceiveMessage: result.canReceiveMessage || exists,
        raw: result
      };

    } catch (error) {
      logger.error(`‚ùå Erro ao verificar n√∫mero (${sessionId}):`, error);
      
      // Se o erro indica que n√£o existe, retornar como n√£o existente
      if (error.message?.includes('not found') || error.message?.includes('invalid')) {
        return {
          success: true,
          exists: false,
          number: phoneNumber.replace(/\D/g, ''),
          error: error.message
        };
      }
      
      throw error;
    }
  }

  /**
   * Desconectar sess√£o
   */
  async disconnect(sessionId) {
    const session = this.sessions.get(sessionId);
    
    if (!session) {
      throw new Error(`Sess√£o ${sessionId} n√£o encontrada`);
    }

    logger.info(`üîå Desconectando ${sessionId}`);

    try {
      // 1. Fazer logout do WhatsApp
      await session.logout();
      logger.info(`   ‚úÖ Logout realizado`);
      
      // 2. üî• CR√çTICO: Fechar o Chrome tamb√©m
      await session.close();
      logger.info(`   ‚úÖ Chrome fechado`);
      
      // 3. Remover do mapa
      this.sessions.delete(sessionId);
      
      logger.info(`‚úÖ ${sessionId} desconectado completamente`);
      
      return { success: true, message: 'Desconectado com sucesso' };

    } catch (error) {
      logger.error(`‚ùå Erro ao desconectar:`, error);
      
      // Tentar fechar com for√ßa se logout falhar
      try {
        await session.close();
        this.sessions.delete(sessionId);
      } catch (closeError) {
        logger.error(`‚ùå Erro ao fechar Chrome:`, closeError);
      }
      
      throw error;
    }
  }

  /**
   * Excluir sess√£o e tokens
   */
  async deleteSession(sessionId) {
    logger.info(`üóëÔ∏è  Excluindo sess√£o ${sessionId}`);

    try {
      // 1. FOR√áAR FECHAMENTO (mata Chrome)
      await this._forceCloseSession(sessionId);
      
      // 2. AGUARDAR PROCESSOS SEREM MORTOS
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // 3. REMOVER PASTA DE TOKENS (com retry se estiver travada)
      const tokenPath = path.join(this.sessionsPath, sessionId);
      
      if (fs.existsSync(tokenPath)) {
        try {
          // Tentar remover normalmente
          fs.rmSync(tokenPath, { recursive: true, force: true });
          logger.info(`‚úÖ Tokens removidos de ${tokenPath}`);
        } catch (error) {
          // Se falhar, for√ßar com comando do sistema
          logger.warn(`‚ö†Ô∏è  Erro ao remover pasta, tentando com for√ßa...`);
          const { execSync } = await import('child_process');
          try {
            execSync(`rm -rf "${tokenPath}"`, { stdio: 'ignore' });
            logger.info(`‚úÖ Tokens removidos com for√ßa`);
          } catch (rmError) {
            logger.error(`‚ùå N√£o foi poss√≠vel remover pasta:`, rmError.message);
          }
        }
      }

      // 4. LIMPAR DO MAPA
      this.sessions.delete(sessionId);
      this.chromePids.delete(sessionId);
      this.clearCallbacks(sessionId);

      logger.info(`‚úÖ Sess√£o ${sessionId} completamente exclu√≠da`);
      return { success: true, message: 'Sess√£o exclu√≠da e Chrome finalizado' };

    } catch (error) {
      logger.error(`‚ùå Erro ao excluir sess√£o:`, error);
      throw error;
    }
  }

  /**
   * Listar sess√µes ativas
   */
  listSessions() {
    const sessions = [];
    
    for (const [sessionId, client] of this.sessions.entries()) {
      sessions.push({
        sessionId,
        active: true
      });
    }
    
    return sessions;
  }

  /**
   * Registrar callback de QR Code
   */
  onQRCode(sessionId, callback) {
    this.qrCodeCallbacks.set(sessionId, callback);
  }

  /**
   * Registrar callback de status
   */
  onStatusChange(sessionId, callback) {
    this.statusCallbacks.set(sessionId, callback);
  }

  /**
   * Limpar callbacks
   */
  clearCallbacks(sessionId) {
    this.qrCodeCallbacks.delete(sessionId);
    this.statusCallbacks.delete(sessionId);
  }

  // ========== M√âTODOS PRIVADOS ==========

  async _isSessionConnected(session) {
    try {
      const state = await session.getConnectionState();
      return state === 'CONNECTED';
    } catch (error) {
      return false;
    }
  }

  async _closeSession(sessionId) {
    const session = this.sessions.get(sessionId);
    if (session) {
      try {
        await session.close();
      } catch (error) {
        logger.error(`Erro ao fechar sess√£o ${sessionId}:`, error);
      }
      this.sessions.delete(sessionId);
    }
    this.clearCallbacks(sessionId);
  }

  /**
   * For√ßar fechamento de sess√£o (matando Chrome se necess√°rio)
   */
  async _forceCloseSession(sessionId) {
    try {
      // Tentar fechar normalmente primeiro
      await this._closeSession(sessionId);
      
      // Matar processos Chrome espec√≠ficos desta sess√£o
      const { execSync } = await import('child_process');
      
      try {
        execSync(`pkill -f "chrome.*${sessionId}" || true`, { stdio: 'ignore' });
        logger.info(`üî™ Processos Chrome da sess√£o ${sessionId} finalizados`);
      } catch (error) {
        // Ignorar erro se n√£o houver processos
      }
      
      // Aguardar um pouco para garantir que tudo foi liberado
      await new Promise(resolve => setTimeout(resolve, 1000));
      
    } catch (error) {
      logger.warn(`Aviso ao for√ßar fechamento de ${sessionId}:`, error.message);
    }
  }

  /**
   * Verificar e matar Chrome travado ANTES de criar sess√£o
   */
  async _checkAndKillStuckChrome(sessionId) {
    try {
      const { execSync } = await import('child_process');
      const sessionPath = path.join(this.sessionsPath, sessionId);
      
      // Verificar se h√° processos Chrome usando esta sess√£o
      try {
        const result = execSync(`ps aux | grep "chrome.*${sessionId}" | grep -v grep | awk '{print $2}'`, { 
          encoding: 'utf-8',
          stdio: ['pipe', 'pipe', 'ignore']
        });
        
        if (result.trim()) {
          const pids = result.trim().split('\n');
          logger.warn(`‚ö†Ô∏è  ${pids.length} processo(s) Chrome travado(s) para ${sessionId}, matando...`);
          
          // Matar cada PID com for√ßa
          for (const pid of pids) {
            try {
              execSync(`kill -9 ${pid}`, { stdio: 'ignore' });
            } catch (e) {
              // Ignorar se processo j√° foi morto
            }
          }
          
          // Aguardar processo ser morto
          await new Promise(resolve => setTimeout(resolve, 2000));
          
          logger.info(`‚úÖ Chrome travado eliminado`);
        }
      } catch (error) {
        // Se n√£o encontrar processos, est√° ok
      }
      
      // Verificar se pasta est√° travada (locked)
      if (fs.existsSync(sessionPath)) {
        const lockFile = path.join(sessionPath, 'SingletonLock');
        if (fs.existsSync(lockFile)) {
          logger.warn(`‚ö†Ô∏è  Lock file detectado em ${sessionId}, removendo...`);
          try {
            fs.unlinkSync(lockFile);
            logger.info(`‚úÖ Lock file removido`);
          } catch (error) {
            logger.error(`‚ùå Erro ao remover lock:`, error.message);
          }
        }
      }
      
    } catch (error) {
      logger.warn(`Aviso ao verificar Chrome travado:`, error.message);
    }
  }

  /**
   * Fechar todas as sess√µes (cleanup)
   */
  async closeAll() {
    logger.info(`üîå Fechando todas as sess√µes...`);
    
    const promises = [];
    for (const [sessionId] of this.sessions.entries()) {
      promises.push(this._closeSession(sessionId));
    }
    
    await Promise.allSettled(promises);
    logger.info(`‚úÖ Todas as sess√µes fechadas`);
  }
}

// Exportar inst√¢ncia √∫nica
export default new WPPService();
